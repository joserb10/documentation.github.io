(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{274:function(e,t,a){"use strict";a.r(t);var r=a(13),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"construccion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#construccion"}},[e._v("#")]),e._v(" Construcción")]),e._v(" "),t("h2",{attrs:{id:"spring-boot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot"}},[e._v("#")]),e._v(" Spring Boot")]),e._v(" "),t("p",[e._v("Para construir la api se hizo uso del framework de Java Spring Boot, este framework está altamente calificado debido a su rendimiento, seguridad entre otros puntos.")]),e._v(" "),t("h2",{attrs:{id:"dependencias"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dependencias"}},[e._v("#")]),e._v(" Dependencias")]),e._v(" "),t("h3",{attrs:{id:"spring-data-jpa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-data-jpa"}},[e._v("#")]),e._v(" Spring Data JPA")]),e._v(" "),t("p",[e._v("Se usó Spring Data JPA como dependcia para consumir datos de la base de datos a través de interfaces.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n")])])]),t("h3",{attrs:{id:"spring-web"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-web"}},[e._v("#")]),e._v(" Spring Web")]),e._v(" "),t("p",[e._v("Se usó Spring Web como soporte para el desarrollo web de api rest.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n")])])]),t("h3",{attrs:{id:"mysql-driver"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-driver"}},[e._v("#")]),e._v(" Mysql Driver")]),e._v(" "),t("p",[e._v("Para permitir la conexión a la base de datos en Mysql.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<scope>runtime</scope>\n    </dependency>\n")])])]),t("h3",{attrs:{id:"lombok"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lombok"}},[e._v("#")]),e._v(" Lombok")]),e._v(" "),t("p",[e._v("Se usó lombok para la reducción y optimización de escritura de código gracias a las anotaciones que permiten generar setters, getters, constructores entre otros.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <dependency>\n\t\t\t<groupId>org.projectlombok</groupId>\n\t\t\t<artifactId>lombok</artifactId>\n\t\t\t<optional>true</optional>\n    </dependency>\n")])])]),t("h3",{attrs:{id:"spring-boot-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-cache"}},[e._v("#")]),e._v(" Spring Boot Cache")]),e._v(" "),t("p",[e._v("Para el cacheado de repositorios y entidades.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-cache</artifactId>\n    </dependency>\n")])])]),t("h2",{attrs:{id:"conexion-a-la-base-de-datos-mysql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conexion-a-la-base-de-datos-mysql"}},[e._v("#")]),e._v(" Conexión a la base de datos Mysql")]),e._v(" "),t("p",[e._v("Para la conexión a la base de datos se remota se hizo uso de la siguiente configuración en aplication.properties. Indicando tanto el servidor, nombre de la base de datos, driver a usar y credenciales de acceso.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    #Conexion a la base de datos\n\n    #Driver para la conexion\n    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n    #Url host y nombre de la base de datos\n    spring.datasource.url=jdbc:mysql://mdb-test.c6vunyturrl6.us-west-1.rds.amazonaws.com/bsale_test\n\n    #Credenciales de la base de datos\n    spring.datasource.username=bsale_test\n    spring.datasource.password=bsale_test\n\n    #Mostrar queries ejecutadas en la base datos\n    spring.jpa.show-sql = true\n")])])]),t("h2",{attrs:{id:"entidades"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#entidades"}},[e._v("#")]),e._v(" Entidades")]),e._v(" "),t("p",[e._v("La primera entidad generada fue Category, en el cual se indica que el identificador debe ser el campo 'id', y debe generarse automaticamente, así tambien se agregó el campo 'name' tipo String.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    @Entity\n    @Table(name = "category")\n    @Getter @Setter @NoArgsConstructor @AllArgsConstructor\n    public class Category {\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private int id;\n        private String name;\n    }\n')])])]),t("p",[e._v("El segunda entidad es Products la cual debe llevar el foreign key de Category, por lo cual se hace uso de la anotación @ManyToOne en el campo 'category' lo cual quiere decir que una categoría posee muchos productos.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    @Entity\n    @Table(name = "product")\n    @Getter @Setter @NoArgsConstructor @AllArgsConstructor\n    public class Product {\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private int id;\n        private String name;\n        private String url_image;\n        private float price;\n        private int discount;\n\n        @ManyToOne(fetch =FetchType.EAGER)\n        @JoinColumn(name="category", nullable=true, referencedColumnName = "id")\n        private Category category;\n    }\n')])])]),t("h2",{attrs:{id:"repositorios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#repositorios"}},[e._v("#")]),e._v(" Repositorios")]),e._v(" "),t("p",[e._v("Para el acceso a la base de datos se generó dos repositorios. El primero es CategoryRepository, es una interfaz que extiende los metodos de la interfaz JpaRepository, ésta última tiene por defecto métodos como findAll() que permite obtener todas los registros.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    public interface CategoryRepository extends JpaRepository<Category, Integer> {\n    }\n\n    @NoRepositoryBean\n    public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T> {\n        List<T> findAll();\n\n        List<T> findAll(Sort sort);\n\n        List<T> findAllById(Iterable<ID> ids);\n\n        <S extends T> List<S> saveAll(Iterable<S> entities);\n\n        void flush();\n        ...\n")])])]),t("p",[e._v("El repositorio de Products es ProductsRepository el cual a diferencia de CategoryRepository extiende la interfaz PagingAndSortingRepository que permite interactuar con la tabla de Products pero de forma paginada. Aquí se realizó la lógica que cada una los requests, teniendo un total de tres queries.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    public interface ProductRepository extends PagingAndSortingRepository<Product, Integer> {\n        //Query para obtener productos por categoria previniendo sql inyection con parametro indexado y con paginacion\n        @Query(value = "select id,name,url_image,price,discount,category from product where category = ?1",\n                countQuery = "select count(*) from product where category = ?1", nativeQuery = true)\n        Page<Product> findByCategory(@Param("category") Integer category, Pageable pageable);\n\n        //Query para obtener productos por busqueda de texto previniendo sql inyection con parametro indexado y con paginacion\n        @Query(value = "select id,name,url_image,price,discount,category from product where name like CONCAT(\'%\', ?1, \'%\')",\n                countQuery = "select count(*) from product where name like \'%?1%\'", nativeQuery = true)\n        Page<Product> findByText(@Param("text") String text, Pageable pageable);\n\n        //Query para obtener productos por rango de precios previniendo sql inyection con parametro indexado y con paginacion\n        @Query(value = "select id,name,url_image,price,discount,category from product where price between ?1 and ?2",\n                countQuery = "select count(*) from product where price between ?1 and ?2", nativeQuery = true)\n        Page<Product> findByPriceRange(@Param("minPrice") Integer minPrice, @Param("maxPrice") Integer maxPrice, Pageable pageable);\n    }\n')])])]),t("h2",{attrs:{id:"servicios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#servicios"}},[e._v("#")]),e._v(" Servicios")]),e._v(" "),t("p",[e._v("El primer servicio, CategoryService, tiene un solo método que permite obtener todas las categorias de la base de datos.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@Service\n    public class CategoryService {\n        //Inyeccion de dependencia repositorio\n        @Autowired\n        CategoryRepository categoryRepository;\n\n        //Obtener todas las categorias\n        public List<Category> findAll() {\n            return categoryRepository.findAll();\n        }\n\n    }\n")])])]),t("p",[e._v("El segundo servicio, ProductService, posee cuatro métodos los cuales permiten obtener todos los productos,\nproductos por categoría, productos por filtro de texto y productos por rango de precios, cada uno paginados.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    @Service\n    public class ProductService {\n        //Inyeccion de dependencia repositorio\n        @Autowired\n        ProductRepository productRepository;\n\n        //Obtener todas los productos\n        public Page<Product> findAll(Pageable pageable) {\n            return productRepository.findAll(pageable);\n        }\n\n        //Obtener todos los productos por categoria\n        public Page<Product> findAllByCategory(Integer category, Pageable pageable) {\n            return productRepository.findByCategory(category, pageable);\n        }\n\n        //Obtener todos los productos por texto busqueda\n            public Page<Product> findAllByText(String text, Pageable pageable) {\n            return productRepository.findByText(text, pageable);\n        }\n\n        //Obtener todos los productos por rango de precios\n        public Page<Product> findAllByPriceRange(Integer minPrice, Integer maxPrice, Pageable pageable) {\n            return productRepository.findByPriceRange(minPrice,maxPrice, pageable);\n        }\n    }\n")])])]),t("h2",{attrs:{id:"rest-controllers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rest-controllers"}},[e._v("#")]),e._v(" Rest Controllers")]),e._v(" "),t("p",[e._v("CategoryController brinda el endpoint '/categories' tipo get para obtener todos las categorias permitiendo el acceso cross origin a todos los origenes.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    @RestController\n    @RequestMapping(value = "categories")\n    public class CategoryController {\n        //Inyeccion de dependencia service\n        @Autowired\n        private CategoryService categoryService;\n\n        //Allow CrossOrigin a todos los clientes\n        @CrossOrigin(origins = "*")\n        //Petición Get con ruta base /categories\n        @GetMapping\n        public ResponseEntity<List<Category>> getAllCategories() {\n            //Obtener todos las categorias desde la base de datos\n            List<Category> categories = categoryService.findAll();\n\n            //Retornar un ResponseEnitity con las categorias y el HttpStatus 200 al cliente\n            return new ResponseEntity<List<Category>>(categories,null, HttpStatus.OK);\n        }\n    }\n')])])]),t("p",[e._v("El ProductController brinda el endpoint 'products' que acepta parametro metros para poder obtener los productos filtrados, se hace uso de una sola función en la cual se valida que parametro está siendo enviado por el cliente para a partir de eso decidir que servicio de products utlizar y devolver una respuesta pagina al cliente.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    @RestController\n    //Direccion base de las peticiones\n    @RequestMapping(value = "/products")\n    public class ProductController {\n        //Inyeccion dependencia service\n        @Autowired\n        private ProductService productService;\n\n        //Allow CrossOrigin a todos los clientes\n        @CrossOrigin(origins = "*")\n        //Petición Get con ruta base /products con paginacion de 8 elementos por pagina\n        @GetMapping\n        public ResponseEntity<?> getAllProductsByFilter(@Nullable @RequestParam("category") Integer category,\n                                                        @Nullable @RequestParam("text") String text,\n                                                        @Nullable @RequestParam("minPrice") Integer minPrice,\n                                                        @Nullable @RequestParam("maxPrice") Integer maxPrice,\n                                                                    @RequestParam(defaultValue = "0") Integer pageNo,\n                                                                    @RequestParam(defaultValue = "8") Integer pageSize,\n                                                                    @RequestParam(defaultValue = "id") String sortBy) {\n            List<Product> products = new ArrayList<>();\n            Page<Product> pagedResult;\n            Pageable paging = PageRequest.of(pageNo, pageSize, Sort.by(sortBy));\n            //Validar que se envíe el parametro category o text o min price\n            if (category != null) {\n                //Obtener todos los productos por categoria desde la base de datos\n                pagedResult = productService.findAllByCategory(category,paging);\n            } else if (text != null){\n                //Obtener todos los productos filtrado por texto\n                pagedResult =  productService.findAllByText(text,paging);\n            } else if (minPrice != null) {\n                //Obtener todos los productos filtrado por rango de precios\n                pagedResult =  productService.findAllByPriceRange(minPrice,maxPrice,paging);\n            } else {\n                //Obtener todos los productos desde la base de datos\n                pagedResult =  productService.findAll(paging);\n            }\n\n            //Si pagedReult contiene datos almacenarlo en array list products\n            if(pagedResult.hasContent()) {\n                products = pagedResult.getContent();\n            }\n\n            //Formar un map que contengo los productos y datos de paginacion\n            Map<String, Object> response = new HashMap<>();\n            response.put("products", products);\n            response.put("currentPage", pagedResult.getNumber());\n            response.put("totalItems", pagedResult.getTotalElements());\n            response.put("totalPages", pagedResult.getTotalPages());\n\n            //Retornar un ResponseEnitity con los datos de response y el HttpStatus 200 al cliente\n            return new ResponseEntity<>(response,null, HttpStatus.OK);\n        }\n\n    }\n')])])])])}),[],!1,null,null,null);t.default=n.exports}}]);